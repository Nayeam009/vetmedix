import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAdmin } from './useAdmin';
import { startOfMonth, endOfMonth, subMonths, format, subDays, startOfDay, endOfDay } from 'date-fns';

export interface OrderAnalytics {
  date: string;
  orders: number;
  revenue: number;
}

export interface StatusDistribution {
  name: string;
  value: number;
  color: string;
}

export interface CategorySales {
  name: string;
  sales: number;
  revenue: number;
}

export interface TopProduct {
  id: string;
  name: string;
  category: string;
  totalSold: number;
  revenue: number;
  image_url: string | null;
}

export interface ClinicStats {
  total: number;
  verified: number;
  pending: number;
  blocked: number;
}

export interface AppointmentStats {
  total: number;
  completed: number;
  confirmed: number;
  pending: number;
  cancelled: number;
}

export interface AnalyticsData {
  // Revenue & Orders
  totalRevenue: number;
  previousMonthRevenue: number;
  revenueGrowth: number;
  totalOrders: number;
  previousMonthOrders: number;
  orderGrowth: number;
  averageOrderValue: number;
  
  // Daily trends (last 14 days)
  dailyTrends: OrderAnalytics[];
  
  // Order status distribution
  orderStatusDistribution: StatusDistribution[];
  
  // Category sales
  categorySales: CategorySales[];
  
  // Top products
  topProducts: TopProduct[];
  
  // Users
  totalUsers: number;
  newUsersThisMonth: number;
  userGrowth: number;
  
  // Clinics
  clinicStats: ClinicStats;
  
  // Appointments
  appointmentStats: AppointmentStats;
  
  // Social
  totalPosts: number;
  postsThisMonth: number;
  totalPets: number;
}

export const useAdminAnalytics = () => {
  const { isAdmin } = useAdmin();
  const queryClient = useQueryClient();

  // Real-time subscriptions for orders and appointments
  useEffect(() => {
    if (!isAdmin) return;

    const channel = supabase
      .channel('admin-analytics-realtime')
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'orders' },
        () => {
          queryClient.invalidateQueries({ queryKey: ['admin-analytics'] });
        }
      )
      .on(
        'postgres_changes',
        { event: '*', schema: 'public', table: 'appointments' },
        () => {
          queryClient.invalidateQueries({ queryKey: ['admin-analytics'] });
        }
      )
      .subscribe();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [isAdmin, queryClient]);

  return useQuery({
    queryKey: ['admin-analytics'],
    queryFn: async (): Promise<AnalyticsData> => {
      const now = new Date();
      const thisMonthStart = startOfMonth(now);
      const lastMonthStart = startOfMonth(subMonths(now, 1));
      const lastMonthEnd = endOfMonth(subMonths(now, 1));
      const fourteenDaysAgo = subDays(now, 14);

      // Fetch all orders
      const { data: allOrders } = await supabase
        .from('orders')
        .select('id, total_amount, status, created_at, items');

      // Fetch all products
      const { data: allProducts } = await supabase
        .from('products')
        .select('id, name, category, image_url, price');

      // Fetch profiles for user count
      const { count: totalUsers } = await supabase
        .from('profiles')
        .select('*', { count: 'exact', head: true });

      const { count: newUsersThisMonth } = await supabase
        .from('profiles')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', thisMonthStart.toISOString());

      const { count: usersLastMonth } = await supabase
        .from('profiles')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', lastMonthStart.toISOString())
        .lte('created_at', lastMonthEnd.toISOString());

      // Fetch clinics
      const { data: clinics } = await supabase
        .from('clinics')
        .select('id, is_verified, is_blocked, verification_status');

      // Fetch appointments
      const { data: appointments } = await supabase
        .from('appointments')
        .select('id, status');

      // Fetch posts
      const { count: totalPosts } = await supabase
        .from('posts')
        .select('*', { count: 'exact', head: true });

      const { count: postsThisMonth } = await supabase
        .from('posts')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', thisMonthStart.toISOString());

      // Fetch pets
      const { count: totalPets } = await supabase
        .from('pets')
        .select('*', { count: 'exact', head: true });

      // Calculate revenue and orders
      const orders = allOrders || [];
      const thisMonthOrders = orders.filter(o => new Date(o.created_at) >= thisMonthStart);
      const lastMonthOrders = orders.filter(o => {
        const date = new Date(o.created_at);
        return date >= lastMonthStart && date <= lastMonthEnd;
      });

      const totalRevenue = orders.reduce((sum, o) => sum + (o.total_amount || 0), 0);
      const thisMonthRevenue = thisMonthOrders.reduce((sum, o) => sum + (o.total_amount || 0), 0);
      const previousMonthRevenue = lastMonthOrders.reduce((sum, o) => sum + (o.total_amount || 0), 0);
      
      const revenueGrowth = previousMonthRevenue > 0 
        ? ((thisMonthRevenue - previousMonthRevenue) / previousMonthRevenue) * 100 
        : 0;
      
      const orderGrowth = lastMonthOrders.length > 0 
        ? ((thisMonthOrders.length - lastMonthOrders.length) / lastMonthOrders.length) * 100 
        : 0;

      const userGrowth = (usersLastMonth || 0) > 0
        ? (((newUsersThisMonth || 0) - (usersLastMonth || 0)) / (usersLastMonth || 1)) * 100
        : 0;

      const averageOrderValue = orders.length > 0 ? totalRevenue / orders.length : 0;

      // Daily trends (last 14 days)
      const dailyTrends: OrderAnalytics[] = [];
      for (let i = 13; i >= 0; i--) {
        const date = subDays(now, i);
        const dayStart = startOfDay(date);
        const dayEnd = endOfDay(date);
        
        const dayOrders = orders.filter(o => {
          const orderDate = new Date(o.created_at);
          return orderDate >= dayStart && orderDate <= dayEnd;
        });

        dailyTrends.push({
          date: format(date, 'MMM d'),
          orders: dayOrders.length,
          revenue: dayOrders.reduce((sum, o) => sum + (o.total_amount || 0), 0),
        });
      }

      // Order status distribution
      const statusCounts = orders.reduce((acc, o) => {
        const status = o.status || 'pending';
        acc[status] = (acc[status] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      const statusColors: Record<string, string> = {
        pending: 'hsl(45, 93%, 47%)',
        processing: 'hsl(217, 91%, 60%)',
        shipped: 'hsl(263, 70%, 50%)',
        delivered: 'hsl(142, 71%, 45%)',
        cancelled: 'hsl(0, 84%, 60%)',
        rejected: 'hsl(0, 72%, 51%)',
      };

      const orderStatusDistribution: StatusDistribution[] = Object.entries(statusCounts).map(([name, value]) => ({
        name: name.charAt(0).toUpperCase() + name.slice(1),
        value,
        color: statusColors[name] || 'hsl(var(--muted))',
      }));

      // Category sales
      const productMap = new Map(allProducts?.map(p => [p.id, p]) || []);
      const categorySalesMap: Record<string, { sales: number; revenue: number }> = {};

      orders.forEach(order => {
        if (order.items && Array.isArray(order.items)) {
          order.items.forEach((item: any) => {
            const product = productMap.get(item.id);
            if (product) {
              const category = product.category || 'Other';
              if (!categorySalesMap[category]) {
                categorySalesMap[category] = { sales: 0, revenue: 0 };
              }
              categorySalesMap[category].sales += item.quantity || 1;
              categorySalesMap[category].revenue += (item.price || 0) * (item.quantity || 1);
            }
          });
        }
      });

      const categorySales: CategorySales[] = Object.entries(categorySalesMap)
        .map(([name, data]) => ({ name, ...data }))
        .sort((a, b) => b.revenue - a.revenue)
        .slice(0, 6);

      // Top products
      const productSalesMap: Record<string, { quantity: number; revenue: number }> = {};

      orders.forEach(order => {
        if (order.items && Array.isArray(order.items)) {
          order.items.forEach((item: any) => {
            if (!productSalesMap[item.id]) {
              productSalesMap[item.id] = { quantity: 0, revenue: 0 };
            }
            productSalesMap[item.id].quantity += item.quantity || 1;
            productSalesMap[item.id].revenue += (item.price || 0) * (item.quantity || 1);
          });
        }
      });

      const topProducts: TopProduct[] = Object.entries(productSalesMap)
        .map(([id, data]) => {
          const product = productMap.get(id);
          return {
            id,
            name: product?.name || 'Unknown Product',
            category: product?.category || 'Other',
            totalSold: data.quantity,
            revenue: data.revenue,
            image_url: product?.image_url || null,
          };
        })
        .sort((a, b) => b.revenue - a.revenue)
        .slice(0, 5);

      // Clinic stats
      const clinicStats: ClinicStats = {
        total: clinics?.length || 0,
        verified: clinics?.filter(c => c.is_verified).length || 0,
        pending: clinics?.filter(c => c.verification_status === 'pending').length || 0,
        blocked: clinics?.filter(c => c.is_blocked).length || 0,
      };

      // Appointment stats
      const appointmentStats: AppointmentStats = {
        total: appointments?.length || 0,
        completed: appointments?.filter(a => a.status === 'completed').length || 0,
        confirmed: appointments?.filter(a => a.status === 'confirmed').length || 0,
        pending: appointments?.filter(a => a.status === 'pending').length || 0,
        cancelled: appointments?.filter(a => a.status === 'cancelled').length || 0,
      };

      return {
        totalRevenue,
        previousMonthRevenue,
        revenueGrowth,
        totalOrders: orders.length,
        previousMonthOrders: lastMonthOrders.length,
        orderGrowth,
        averageOrderValue,
        dailyTrends,
        orderStatusDistribution,
        categorySales,
        topProducts,
        totalUsers: totalUsers || 0,
        newUsersThisMonth: newUsersThisMonth || 0,
        userGrowth,
        clinicStats,
        appointmentStats,
        totalPosts: totalPosts || 0,
        postsThisMonth: postsThisMonth || 0,
        totalPets: totalPets || 0,
      };
    },
    enabled: isAdmin,
    staleTime: 1000 * 60 * 2, // 2 minutes - shorter for real-time responsiveness
  });
};
